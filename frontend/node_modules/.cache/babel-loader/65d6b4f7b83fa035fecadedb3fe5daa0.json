{"ast":null,"code":"// Based on https://github.com/dscape/cycle/blob/master/cycle.js\nmodule.exports = function decycle(object) {\n  // Make a deep copy of an object or array, assuring that there is at most\n  // one instance of each object or array in the resulting structure. The\n  // duplicate references (which might be forming cycles) are replaced with\n  // an object of the form\n  //      {$ref: PATH}\n  // where the PATH is a JSONPath string that locates the first occurance.\n  // So,\n  //      var a = [];\n  //      a[0] = a;\n  //      return JSON.stringify(JSON.decycle(a));\n  // produces the string '[{\"$ref\":\"$\"}]'.\n  // JSONPath is used to locate the unique object. $ indicates the top level of\n  // the object or array. [NUMBER] or [STRING] indicates a child member or\n  // property.\n  var objects = [],\n      // Keep a reference to each unique object or array\n  paths = []; // Keep the path to each unique object or array\n\n  return function derez(value, path) {\n    // The derez recurses through the object, producing the deep copy.\n    var i, // The loop counter\n    name, // Property name\n    nu; // The new object or array\n    // typeof null === 'object', so go on if this value is really an object but not\n    // one of the weird builtin objects.\n\n    if (typeof value === 'object' && value !== null && !(value instanceof Boolean) && !(value instanceof Date) && !(value instanceof Number) && !(value instanceof RegExp) && !(value instanceof String)) {\n      // If the value is an object or array, look to see if we have already\n      // encountered it. If so, return a $ref/path object. This is a hard way,\n      // linear search that will get slower as the number of unique objects grows.\n      for (i = 0; i < objects.length; i += 1) {\n        if (objects[i] === value) {\n          return {\n            $ref: paths[i]\n          };\n        }\n      } // Otherwise, accumulate the unique value and its path.\n\n\n      objects.push(value);\n      paths.push(path); // If it is an array, replicate the array.\n\n      if (Object.prototype.toString.apply(value) === '[object Array]') {\n        nu = [];\n\n        for (i = 0; i < value.length; i += 1) {\n          nu[i] = derez(value[i], path + '[' + i + ']');\n        }\n      } else {\n        // If it is an object, replicate the object.\n        nu = {};\n\n        for (name in value) {\n          if (Object.prototype.hasOwnProperty.call(value, name)) {\n            nu[name] = derez(value[name], path + '[' + JSON.stringify(name) + ']');\n          }\n        }\n      }\n\n      return nu;\n    }\n\n    return value;\n  }(object, '$');\n};","map":{"version":3,"sources":["C:/Users/aleor/Desktop/Code/wbsc/frontend/node_modules/sc-errors/decycle.js"],"names":["module","exports","decycle","object","objects","paths","derez","value","path","i","name","nu","Boolean","Date","Number","RegExp","String","length","$ref","push","Object","prototype","toString","apply","hasOwnProperty","call","JSON","stringify"],"mappings":"AAAA;AAEAA,MAAM,CAACC,OAAP,GAAiB,SAASC,OAAT,CAAiBC,MAAjB,EAAyB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEI,MAAIC,OAAO,GAAG,EAAd;AAAA,MAAoB;AAChBC,EAAAA,KAAK,GAAG,EADZ,CAjBsC,CAkBlB;;AAEpB,SAAQ,SAASC,KAAT,CAAeC,KAAf,EAAsBC,IAAtB,EAA4B;AAExC;AAEQ,QAAIC,CAAJ,EAAgB;AACZC,IAAAA,IADJ,EACgB;AACZC,IAAAA,EAFJ,CAJgC,CAMhB;AAExB;AACA;;AAEQ,QAAI,OAAOJ,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,KAAK,IAAvC,IACI,EAAEA,KAAK,YAAYK,OAAnB,CADJ,IAEI,EAAEL,KAAK,YAAYM,IAAnB,CAFJ,IAGI,EAAEN,KAAK,YAAYO,MAAnB,CAHJ,IAII,EAAEP,KAAK,YAAYQ,MAAnB,CAJJ,IAKI,EAAER,KAAK,YAAYS,MAAnB,CALR,EAKoC;AAE5C;AACA;AACA;AAEY,WAAKP,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGL,OAAO,CAACa,MAAxB,EAAgCR,CAAC,IAAI,CAArC,EAAwC;AACpC,YAAIL,OAAO,CAACK,CAAD,CAAP,KAAeF,KAAnB,EAA0B;AACtB,iBAAO;AAACW,YAAAA,IAAI,EAAEb,KAAK,CAACI,CAAD;AAAZ,WAAP;AACH;AACJ,OAV+B,CAY5C;;;AAEYL,MAAAA,OAAO,CAACe,IAAR,CAAaZ,KAAb;AACAF,MAAAA,KAAK,CAACc,IAAN,CAAWX,IAAX,EAfgC,CAiB5C;;AAEY,UAAIY,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,KAA1B,CAAgChB,KAAhC,MAA2C,gBAA/C,EAAiE;AAC7DI,QAAAA,EAAE,GAAG,EAAL;;AACA,aAAKF,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGF,KAAK,CAACU,MAAtB,EAA8BR,CAAC,IAAI,CAAnC,EAAsC;AAClCE,UAAAA,EAAE,CAACF,CAAD,CAAF,GAAQH,KAAK,CAACC,KAAK,CAACE,CAAD,CAAN,EAAWD,IAAI,GAAG,GAAP,GAAaC,CAAb,GAAiB,GAA5B,CAAb;AACH;AACJ,OALD,MAKO;AAEnB;AAEgBE,QAAAA,EAAE,GAAG,EAAL;;AACA,aAAKD,IAAL,IAAaH,KAAb,EAAoB;AAChB,cAAIa,MAAM,CAACC,SAAP,CAAiBG,cAAjB,CAAgCC,IAAhC,CAAqClB,KAArC,EAA4CG,IAA5C,CAAJ,EAAuD;AACnDC,YAAAA,EAAE,CAACD,IAAD,CAAF,GAAWJ,KAAK,CAACC,KAAK,CAACG,IAAD,CAAN,EACZF,IAAI,GAAG,GAAP,GAAakB,IAAI,CAACC,SAAL,CAAejB,IAAf,CAAb,GAAoC,GADxB,CAAhB;AAEH;AACJ;AACJ;;AACD,aAAOC,EAAP;AACH;;AACD,WAAOJ,KAAP;AACH,GAvDO,CAuDNJ,MAvDM,EAuDE,GAvDF,CAAR;AAwDH,CA5ED","sourcesContent":["// Based on https://github.com/dscape/cycle/blob/master/cycle.js\n\nmodule.exports = function decycle(object) {\n// Make a deep copy of an object or array, assuring that there is at most\n// one instance of each object or array in the resulting structure. The\n// duplicate references (which might be forming cycles) are replaced with\n// an object of the form\n//      {$ref: PATH}\n// where the PATH is a JSONPath string that locates the first occurance.\n// So,\n//      var a = [];\n//      a[0] = a;\n//      return JSON.stringify(JSON.decycle(a));\n// produces the string '[{\"$ref\":\"$\"}]'.\n\n// JSONPath is used to locate the unique object. $ indicates the top level of\n// the object or array. [NUMBER] or [STRING] indicates a child member or\n// property.\n\n    var objects = [],   // Keep a reference to each unique object or array\n        paths = [];     // Keep the path to each unique object or array\n\n    return (function derez(value, path) {\n\n// The derez recurses through the object, producing the deep copy.\n\n        var i,          // The loop counter\n            name,       // Property name\n            nu;         // The new object or array\n\n// typeof null === 'object', so go on if this value is really an object but not\n// one of the weird builtin objects.\n\n        if (typeof value === 'object' && value !== null &&\n                !(value instanceof Boolean) &&\n                !(value instanceof Date)    &&\n                !(value instanceof Number)  &&\n                !(value instanceof RegExp)  &&\n                !(value instanceof String)) {\n\n// If the value is an object or array, look to see if we have already\n// encountered it. If so, return a $ref/path object. This is a hard way,\n// linear search that will get slower as the number of unique objects grows.\n\n            for (i = 0; i < objects.length; i += 1) {\n                if (objects[i] === value) {\n                    return {$ref: paths[i]};\n                }\n            }\n\n// Otherwise, accumulate the unique value and its path.\n\n            objects.push(value);\n            paths.push(path);\n\n// If it is an array, replicate the array.\n\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                nu = [];\n                for (i = 0; i < value.length; i += 1) {\n                    nu[i] = derez(value[i], path + '[' + i + ']');\n                }\n            } else {\n\n// If it is an object, replicate the object.\n\n                nu = {};\n                for (name in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, name)) {\n                        nu[name] = derez(value[name],\n                            path + '[' + JSON.stringify(name) + ']');\n                    }\n                }\n            }\n            return nu;\n        }\n        return value;\n    }(object, '$'));\n};\n"]},"metadata":{},"sourceType":"script"}