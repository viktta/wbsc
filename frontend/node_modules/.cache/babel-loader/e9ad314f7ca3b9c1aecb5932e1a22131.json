{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\nexports.INIT_ACTION = exports.ActionCreators = exports.ActionTypes = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nexports.liftAction = liftAction;\nexports.liftReducerWith = liftReducerWith;\nexports.unliftState = unliftState;\nexports.unliftStore = unliftStore;\nexports.default = instrument;\n\nvar _difference = require('lodash/difference');\n\nvar _difference2 = _interopRequireDefault(_difference);\n\nvar _union = require('lodash/union');\n\nvar _union2 = _interopRequireDefault(_union);\n\nvar _isPlainObject = require('lodash/isPlainObject');\n\nvar _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n\nvar _symbolObservable = require('symbol-observable');\n\nvar _symbolObservable2 = _interopRequireDefault(_symbolObservable);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar ActionTypes = exports.ActionTypes = {\n  PERFORM_ACTION: 'PERFORM_ACTION',\n  RESET: 'RESET',\n  ROLLBACK: 'ROLLBACK',\n  COMMIT: 'COMMIT',\n  SWEEP: 'SWEEP',\n  TOGGLE_ACTION: 'TOGGLE_ACTION',\n  SET_ACTIONS_ACTIVE: 'SET_ACTIONS_ACTIVE',\n  JUMP_TO_STATE: 'JUMP_TO_STATE',\n  JUMP_TO_ACTION: 'JUMP_TO_ACTION',\n  REORDER_ACTION: 'REORDER_ACTION',\n  IMPORT_STATE: 'IMPORT_STATE',\n  LOCK_CHANGES: 'LOCK_CHANGES',\n  PAUSE_RECORDING: 'PAUSE_RECORDING'\n};\nvar isChrome = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && (typeof window.chrome !== 'undefined' || typeof window.process !== 'undefined' && window.process.type === 'renderer');\nvar isChromeOrNode = isChrome || typeof process !== 'undefined' && process.release && process.release.name === 'node';\n/**\n * Action creators to change the History state.\n */\n\nvar ActionCreators = exports.ActionCreators = {\n  performAction: function performAction(action, trace, traceLimit, toExcludeFromTrace) {\n    if (!(0, _isPlainObject2.default)(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n\n    var stack = void 0;\n\n    if (trace) {\n      var extraFrames = 0;\n\n      if (typeof trace === 'function') {\n        stack = trace(action);\n      } else {\n        var error = Error();\n        var prevStackTraceLimit = void 0;\n\n        if (Error.captureStackTrace && isChromeOrNode) {\n          // avoid error-polyfill\n          if (Error.stackTraceLimit < traceLimit) {\n            prevStackTraceLimit = Error.stackTraceLimit;\n            Error.stackTraceLimit = traceLimit;\n          }\n\n          Error.captureStackTrace(error, toExcludeFromTrace);\n        } else {\n          extraFrames = 3;\n        }\n\n        stack = error.stack;\n        if (prevStackTraceLimit) Error.stackTraceLimit = prevStackTraceLimit;\n\n        if (extraFrames || typeof Error.stackTraceLimit !== 'number' || Error.stackTraceLimit > traceLimit) {\n          var frames = stack.split('\\n');\n\n          if (frames.length > traceLimit) {\n            stack = frames.slice(0, traceLimit + extraFrames + (frames[0] === 'Error' ? 1 : 0)).join('\\n');\n          }\n        }\n      }\n    }\n\n    return {\n      type: ActionTypes.PERFORM_ACTION,\n      action: action,\n      timestamp: Date.now(),\n      stack: stack\n    };\n  },\n  reset: function reset() {\n    return {\n      type: ActionTypes.RESET,\n      timestamp: Date.now()\n    };\n  },\n  rollback: function rollback() {\n    return {\n      type: ActionTypes.ROLLBACK,\n      timestamp: Date.now()\n    };\n  },\n  commit: function commit() {\n    return {\n      type: ActionTypes.COMMIT,\n      timestamp: Date.now()\n    };\n  },\n  sweep: function sweep() {\n    return {\n      type: ActionTypes.SWEEP\n    };\n  },\n  toggleAction: function toggleAction(id) {\n    return {\n      type: ActionTypes.TOGGLE_ACTION,\n      id: id\n    };\n  },\n  setActionsActive: function setActionsActive(start, end) {\n    var active = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return {\n      type: ActionTypes.SET_ACTIONS_ACTIVE,\n      start: start,\n      end: end,\n      active: active\n    };\n  },\n  reorderAction: function reorderAction(actionId, beforeActionId) {\n    return {\n      type: ActionTypes.REORDER_ACTION,\n      actionId: actionId,\n      beforeActionId: beforeActionId\n    };\n  },\n  jumpToState: function jumpToState(index) {\n    return {\n      type: ActionTypes.JUMP_TO_STATE,\n      index: index\n    };\n  },\n  jumpToAction: function jumpToAction(actionId) {\n    return {\n      type: ActionTypes.JUMP_TO_ACTION,\n      actionId: actionId\n    };\n  },\n  importState: function importState(nextLiftedState, noRecompute) {\n    return {\n      type: ActionTypes.IMPORT_STATE,\n      nextLiftedState: nextLiftedState,\n      noRecompute: noRecompute\n    };\n  },\n  lockChanges: function lockChanges(status) {\n    return {\n      type: ActionTypes.LOCK_CHANGES,\n      status: status\n    };\n  },\n  pauseRecording: function pauseRecording(status) {\n    return {\n      type: ActionTypes.PAUSE_RECORDING,\n      status: status\n    };\n  }\n};\nvar INIT_ACTION = exports.INIT_ACTION = {\n  type: '@@INIT'\n};\n/**\n * Computes the next entry with exceptions catching.\n */\n\nfunction computeWithTryCatch(reducer, action, state) {\n  var nextState = state;\n  var nextError = void 0;\n\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n\n    if (isChrome) {\n      // In Chrome, rethrowing provides better source map support\n      setTimeout(function () {\n        throw err;\n      });\n    } else {\n      console.error(err);\n    }\n  }\n\n  return {\n    state: nextState,\n    error: nextError\n  };\n}\n/**\n * Computes the next entry in the log by applying an action.\n */\n\n\nfunction computeNextEntry(reducer, action, state, shouldCatchErrors) {\n  if (!shouldCatchErrors) {\n    return {\n      state: reducer(state, action)\n    };\n  }\n\n  return computeWithTryCatch(reducer, action, state);\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\n\n\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, shouldCatchErrors) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (!computedStates || minInvalidatedStateIndex === -1 || minInvalidatedStateIndex >= computedStates.length && computedStates.length === stagedActionIds.length) {\n    return computedStates;\n  }\n\n  var nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n\n  for (var i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {\n    var actionId = stagedActionIds[i];\n    var action = actionsById[actionId].action;\n    var previousEntry = nextComputedStates[i - 1];\n    var previousState = previousEntry ? previousEntry.state : committedState;\n    var shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    var entry = void 0;\n\n    if (shouldSkip) {\n      entry = previousEntry;\n    } else {\n      if (shouldCatchErrors && previousEntry && previousEntry.error) {\n        entry = {\n          state: previousState,\n          error: 'Interrupted by an error up the chain'\n        };\n      } else {\n        entry = computeNextEntry(reducer, action, previousState, shouldCatchErrors);\n      }\n    }\n\n    nextComputedStates.push(entry);\n  }\n\n  return nextComputedStates;\n}\n/**\n * Lifts an app's action into an action on the lifted store.\n */\n\n\nfunction liftAction(action, trace, traceLimit, toExcludeFromTrace) {\n  return ActionCreators.performAction(action, trace, traceLimit, toExcludeFromTrace);\n}\n/**\n * Creates a history state reducer from an app's reducer.\n */\n\n\nfunction liftReducerWith(reducer, initialCommittedState, monitorReducer, options) {\n  var initialLiftedState = {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: {\n      0: liftAction(INIT_ACTION)\n    },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: options.shouldStartLocked === true,\n    isPaused: options.shouldRecordChanges === false\n  };\n  /**\n   * Manages how the history actions modify the history state.\n   */\n\n  return function (liftedState, liftedAction) {\n    var _ref = liftedState || initialLiftedState,\n        monitorState = _ref.monitorState,\n        actionsById = _ref.actionsById,\n        nextActionId = _ref.nextActionId,\n        stagedActionIds = _ref.stagedActionIds,\n        skippedActionIds = _ref.skippedActionIds,\n        committedState = _ref.committedState,\n        currentStateIndex = _ref.currentStateIndex,\n        computedStates = _ref.computedStates,\n        isLocked = _ref.isLocked,\n        isPaused = _ref.isPaused;\n\n    if (!liftedState) {\n      // Prevent mutating initialLiftedState\n      actionsById = _extends({}, actionsById);\n    }\n\n    function commitExcessActions(n) {\n      // Auto-commits n-number of excess actions.\n      var excess = n;\n      var idsToDelete = stagedActionIds.slice(1, excess + 1);\n\n      for (var i = 0; i < idsToDelete.length; i++) {\n        if (computedStates[i + 1].error) {\n          // Stop if error is found. Commit actions up to error.\n          excess = i;\n          idsToDelete = stagedActionIds.slice(1, excess + 1);\n          break;\n        } else {\n          delete actionsById[idsToDelete[i]];\n        }\n      }\n\n      skippedActionIds = skippedActionIds.filter(function (id) {\n        return idsToDelete.indexOf(id) === -1;\n      });\n      stagedActionIds = [0].concat(stagedActionIds.slice(excess + 1));\n      committedState = computedStates[excess].state;\n      computedStates = computedStates.slice(excess);\n      currentStateIndex = currentStateIndex > excess ? currentStateIndex - excess : 0;\n    }\n\n    function computePausedAction(shouldInit) {\n      var _extends2;\n\n      var computedState = void 0;\n\n      if (shouldInit) {\n        computedState = computedStates[currentStateIndex];\n        monitorState = monitorReducer(monitorState, liftedAction);\n      } else {\n        computedState = computeNextEntry(reducer, liftedAction.action, computedStates[currentStateIndex].state, false);\n      }\n\n      if (!options.pauseActionType || nextActionId === 1) {\n        return {\n          monitorState: monitorState,\n          actionsById: {\n            0: liftAction(INIT_ACTION)\n          },\n          nextActionId: 1,\n          stagedActionIds: [0],\n          skippedActionIds: [],\n          committedState: computedState.state,\n          currentStateIndex: 0,\n          computedStates: [computedState],\n          isLocked: isLocked,\n          isPaused: true\n        };\n      }\n\n      if (shouldInit) {\n        if (currentStateIndex === stagedActionIds.length - 1) {\n          currentStateIndex++;\n        }\n\n        stagedActionIds = [].concat(stagedActionIds, [nextActionId]);\n        nextActionId++;\n      }\n\n      return {\n        monitorState: monitorState,\n        actionsById: _extends({}, actionsById, (_extends2 = {}, _extends2[nextActionId - 1] = liftAction({\n          type: options.pauseActionType\n        }), _extends2)),\n        nextActionId: nextActionId,\n        stagedActionIds: stagedActionIds,\n        skippedActionIds: skippedActionIds,\n        committedState: committedState,\n        currentStateIndex: currentStateIndex,\n        computedStates: [].concat(computedStates.slice(0, stagedActionIds.length - 1), [computedState]),\n        isLocked: isLocked,\n        isPaused: true\n      };\n    } // By default, agressively recompute every state whatever happens.\n    // This has O(n) performance, so we'll override this to a sensible\n    // value whenever we feel like we don't have to recompute the states.\n\n\n    var minInvalidatedStateIndex = 0; // maxAge number can be changed dynamically\n\n    var maxAge = options.maxAge;\n    if (typeof maxAge === 'function') maxAge = maxAge(liftedAction, liftedState);\n\n    if (/^@@redux\\/(INIT|REPLACE)/.test(liftedAction.type)) {\n      if (options.shouldHotReload === false) {\n        actionsById = {\n          0: liftAction(INIT_ACTION)\n        };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = computedStates.length === 0 ? initialCommittedState : computedStates[currentStateIndex].state;\n        currentStateIndex = 0;\n        computedStates = [];\n      } // Recompute states on hot reload and init.\n\n\n      minInvalidatedStateIndex = 0;\n\n      if (maxAge && stagedActionIds.length > maxAge) {\n        // States must be recomputed before committing excess.\n        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, options.shouldCatchErrors);\n        commitExcessActions(stagedActionIds.length - maxAge); // Avoid double computation.\n\n        minInvalidatedStateIndex = Infinity;\n      }\n    } else {\n      switch (liftedAction.type) {\n        case ActionTypes.PERFORM_ACTION:\n          {\n            if (isLocked) return liftedState || initialLiftedState;\n            if (isPaused) return computePausedAction(); // Auto-commit as new actions come in.\n\n            if (maxAge && stagedActionIds.length >= maxAge) {\n              commitExcessActions(stagedActionIds.length - maxAge + 1);\n            }\n\n            if (currentStateIndex === stagedActionIds.length - 1) {\n              currentStateIndex++;\n            }\n\n            var actionId = nextActionId++; // Mutation! This is the hottest path, and we optimize on purpose.\n            // It is safe because we set a new key in a cache dictionary.\n\n            actionsById[actionId] = liftedAction;\n            stagedActionIds = [].concat(stagedActionIds, [actionId]); // Optimization: we know that only the new action needs computing.\n\n            minInvalidatedStateIndex = stagedActionIds.length - 1;\n            break;\n          }\n\n        case ActionTypes.RESET:\n          {\n            // Get back to the state the store was created with.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = initialCommittedState;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        case ActionTypes.COMMIT:\n          {\n            // Consider the last committed state the new starting point.\n            // Squash any staged actions into a single committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        case ActionTypes.ROLLBACK:\n          {\n            // Forget about any staged actions.\n            // Start again from the last committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        case ActionTypes.TOGGLE_ACTION:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            var _actionId = liftedAction.id;\n            var index = skippedActionIds.indexOf(_actionId);\n\n            if (index === -1) {\n              skippedActionIds = [_actionId].concat(skippedActionIds);\n            } else {\n              skippedActionIds = skippedActionIds.filter(function (id) {\n                return id !== _actionId;\n              });\n            } // Optimization: we know history before this action hasn't changed\n\n\n            minInvalidatedStateIndex = stagedActionIds.indexOf(_actionId);\n            break;\n          }\n\n        case ActionTypes.SET_ACTIONS_ACTIVE:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            var start = liftedAction.start,\n                end = liftedAction.end,\n                active = liftedAction.active;\n            var actionIds = [];\n\n            for (var i = start; i < end; i++) {\n              actionIds.push(i);\n            }\n\n            if (active) {\n              skippedActionIds = (0, _difference2.default)(skippedActionIds, actionIds);\n            } else {\n              skippedActionIds = (0, _union2.default)(skippedActionIds, actionIds);\n            } // Optimization: we know history before this action hasn't changed\n\n\n            minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n            break;\n          }\n\n        case ActionTypes.JUMP_TO_STATE:\n          {\n            // Without recomputing anything, move the pointer that tell us\n            // which state is considered the current one. Useful for sliders.\n            currentStateIndex = liftedAction.index; // Optimization: we know the history has not changed.\n\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case ActionTypes.JUMP_TO_ACTION:\n          {\n            // Jumps to a corresponding state to a specific action.\n            // Useful when filtering actions.\n            var _index = stagedActionIds.indexOf(liftedAction.actionId);\n\n            if (_index !== -1) currentStateIndex = _index;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case ActionTypes.SWEEP:\n          {\n            // Forget any actions that are currently being skipped.\n            stagedActionIds = (0, _difference2.default)(stagedActionIds, skippedActionIds);\n            skippedActionIds = [];\n            currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n            break;\n          }\n\n        case ActionTypes.REORDER_ACTION:\n          {\n            // Recompute actions in a new order.\n            var _actionId2 = liftedAction.actionId;\n            var idx = stagedActionIds.indexOf(_actionId2); // do nothing in case the action is already removed or trying to move the first action\n\n            if (idx < 1) break;\n            var beforeActionId = liftedAction.beforeActionId;\n            var newIdx = stagedActionIds.indexOf(beforeActionId);\n\n            if (newIdx < 1) {\n              // move to the beginning or to the end\n              var count = stagedActionIds.length;\n              newIdx = beforeActionId > stagedActionIds[count - 1] ? count : 1;\n            }\n\n            var diff = idx - newIdx;\n\n            if (diff > 0) {\n              // move left\n              stagedActionIds = [].concat(stagedActionIds.slice(0, newIdx), [_actionId2], stagedActionIds.slice(newIdx, idx), stagedActionIds.slice(idx + 1));\n              minInvalidatedStateIndex = newIdx;\n            } else if (diff < 0) {\n              // move right\n              stagedActionIds = [].concat(stagedActionIds.slice(0, idx), stagedActionIds.slice(idx + 1, newIdx), [_actionId2], stagedActionIds.slice(newIdx));\n              minInvalidatedStateIndex = idx;\n            }\n\n            break;\n          }\n\n        case ActionTypes.IMPORT_STATE:\n          {\n            if (Array.isArray(liftedAction.nextLiftedState)) {\n              // recompute array of actions\n              actionsById = {\n                0: liftAction(INIT_ACTION)\n              };\n              nextActionId = 1;\n              stagedActionIds = [0];\n              skippedActionIds = [];\n              currentStateIndex = liftedAction.nextLiftedState.length;\n              computedStates = [];\n              committedState = liftedAction.preloadedState;\n              minInvalidatedStateIndex = 0; // iterate through actions\n\n              liftedAction.nextLiftedState.forEach(function (action) {\n                actionsById[nextActionId] = liftAction(action, options.trace || options.shouldIncludeCallstack);\n                stagedActionIds.push(nextActionId);\n                nextActionId++;\n              });\n            } else {\n              var _liftedAction$nextLif = liftedAction.nextLiftedState; // Completely replace everything.\n\n              monitorState = _liftedAction$nextLif.monitorState;\n              actionsById = _liftedAction$nextLif.actionsById;\n              nextActionId = _liftedAction$nextLif.nextActionId;\n              stagedActionIds = _liftedAction$nextLif.stagedActionIds;\n              skippedActionIds = _liftedAction$nextLif.skippedActionIds;\n              committedState = _liftedAction$nextLif.committedState;\n              currentStateIndex = _liftedAction$nextLif.currentStateIndex;\n              computedStates = _liftedAction$nextLif.computedStates;\n\n              if (liftedAction.noRecompute) {\n                minInvalidatedStateIndex = Infinity;\n              }\n            }\n\n            break;\n          }\n\n        case ActionTypes.LOCK_CHANGES:\n          {\n            isLocked = liftedAction.status;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n\n        case ActionTypes.PAUSE_RECORDING:\n          {\n            isPaused = liftedAction.status;\n\n            if (isPaused) {\n              return computePausedAction(true);\n            } // Commit when unpausing\n\n\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n\n        default:\n          {\n            // If the action is not recognized, it's a monitor action.\n            // Optimization: a monitor action can't change history.\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n      }\n    }\n\n    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, options.shouldCatchErrors);\n    monitorState = monitorReducer(monitorState, liftedAction);\n    return {\n      monitorState: monitorState,\n      actionsById: actionsById,\n      nextActionId: nextActionId,\n      stagedActionIds: stagedActionIds,\n      skippedActionIds: skippedActionIds,\n      committedState: committedState,\n      currentStateIndex: currentStateIndex,\n      computedStates: computedStates,\n      isLocked: isLocked,\n      isPaused: isPaused\n    };\n  };\n}\n/**\n * Provides an app's view into the state of the lifted store.\n */\n\n\nfunction unliftState(liftedState) {\n  var computedStates = liftedState.computedStates,\n      currentStateIndex = liftedState.currentStateIndex;\n  var state = computedStates[currentStateIndex].state;\n  return state;\n}\n/**\n * Provides an app's view into the lifted store.\n */\n\n\nfunction unliftStore(liftedStore, liftReducer, options) {\n  var _extends3;\n\n  var lastDefinedState = void 0;\n  var trace = options.trace || options.shouldIncludeCallstack;\n  var traceLimit = options.traceLimit || 10;\n\n  function getState() {\n    var state = unliftState(liftedStore.getState());\n\n    if (state !== undefined) {\n      lastDefinedState = state;\n    }\n\n    return lastDefinedState;\n  }\n\n  function dispatch(action) {\n    liftedStore.dispatch(liftAction(action, trace, traceLimit, dispatch));\n    return action;\n  }\n\n  return _extends({}, liftedStore, (_extends3 = {\n    liftedStore: liftedStore,\n    dispatch: dispatch,\n    getState: getState,\n    replaceReducer: function replaceReducer(nextReducer) {\n      liftedStore.replaceReducer(liftReducer(nextReducer));\n    }\n  }, _extends3[_symbolObservable2.default] = function () {\n    return _extends({}, liftedStore[_symbolObservable2.default](), {\n      subscribe: function subscribe(observer) {\n        if ((typeof observer === 'undefined' ? 'undefined' : _typeof(observer)) !== 'object') {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = liftedStore.subscribe(observeState);\n        return {\n          unsubscribe: unsubscribe\n        };\n      }\n    });\n  }, _extends3));\n}\n/**\n * Redux instrumentation store enhancer.\n */\n\n\nfunction instrument() {\n  var monitorReducer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n    return null;\n  };\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof options.maxAge === 'number' && options.maxAge < 2) {\n    throw new Error('DevTools.instrument({ maxAge }) option, if specified, ' + 'may not be less than 2.');\n  }\n\n  return function (createStore) {\n    return function (reducer, initialState, enhancer) {\n      function liftReducer(r) {\n        if (typeof r !== 'function') {\n          if (r && typeof r.default === 'function') {\n            throw new Error('Expected the reducer to be a function. ' + 'Instead got an object with a \"default\" field. ' + 'Did you pass a module instead of the default export? ' + 'Try passing require(...).default instead.');\n          }\n\n          throw new Error('Expected the reducer to be a function.');\n        }\n\n        return liftReducerWith(r, initialState, monitorReducer, options);\n      }\n\n      var liftedStore = createStore(liftReducer(reducer), enhancer);\n\n      if (liftedStore.liftedStore) {\n        throw new Error('DevTools instrumentation should not be applied more than once. ' + 'Check your store configuration.');\n      }\n\n      return unliftStore(liftedStore, liftReducer, options);\n    };\n  };\n}","map":{"version":3,"sources":["C:/Users/aleor/Desktop/Code/wbsc/frontend/node_modules/redux-devtools-instrument/lib/instrument.js"],"names":["exports","__esModule","INIT_ACTION","ActionCreators","ActionTypes","undefined","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_typeof","Symbol","iterator","obj","constructor","liftAction","liftReducerWith","unliftState","unliftStore","default","instrument","_difference","require","_difference2","_interopRequireDefault","_union","_union2","_isPlainObject","_isPlainObject2","_symbolObservable","_symbolObservable2","PERFORM_ACTION","RESET","ROLLBACK","COMMIT","SWEEP","TOGGLE_ACTION","SET_ACTIONS_ACTIVE","JUMP_TO_STATE","JUMP_TO_ACTION","REORDER_ACTION","IMPORT_STATE","LOCK_CHANGES","PAUSE_RECORDING","isChrome","window","chrome","process","type","isChromeOrNode","release","name","performAction","action","trace","traceLimit","toExcludeFromTrace","Error","stack","extraFrames","error","prevStackTraceLimit","captureStackTrace","stackTraceLimit","frames","split","slice","join","timestamp","Date","now","reset","rollback","commit","sweep","toggleAction","id","setActionsActive","start","end","active","reorderAction","actionId","beforeActionId","jumpToState","index","jumpToAction","importState","nextLiftedState","noRecompute","lockChanges","status","pauseRecording","computeWithTryCatch","reducer","state","nextState","nextError","err","toString","setTimeout","console","computeNextEntry","shouldCatchErrors","recomputeStates","computedStates","minInvalidatedStateIndex","committedState","actionsById","stagedActionIds","skippedActionIds","nextComputedStates","previousEntry","previousState","shouldSkip","indexOf","entry","push","initialCommittedState","monitorReducer","options","initialLiftedState","monitorState","nextActionId","currentStateIndex","isLocked","shouldStartLocked","isPaused","shouldRecordChanges","liftedState","liftedAction","_ref","commitExcessActions","n","excess","idsToDelete","filter","concat","computePausedAction","shouldInit","_extends2","computedState","pauseActionType","maxAge","test","shouldHotReload","Infinity","_actionId","actionIds","_index","Math","min","_actionId2","idx","newIdx","count","diff","Array","isArray","preloadedState","forEach","shouldIncludeCallstack","_liftedAction$nextLif","liftedStore","liftReducer","_extends3","lastDefinedState","getState","dispatch","replaceReducer","nextReducer","subscribe","observer","TypeError","observeState","next","unsubscribe","createStore","initialState","enhancer","r"],"mappings":"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","sourcesContent":["'use strict';\n\nexports.__esModule = true;\nexports.INIT_ACTION = exports.ActionCreators = exports.ActionTypes = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.liftAction = liftAction;\nexports.liftReducerWith = liftReducerWith;\nexports.unliftState = unliftState;\nexports.unliftStore = unliftStore;\nexports.default = instrument;\n\nvar _difference = require('lodash/difference');\n\nvar _difference2 = _interopRequireDefault(_difference);\n\nvar _union = require('lodash/union');\n\nvar _union2 = _interopRequireDefault(_union);\n\nvar _isPlainObject = require('lodash/isPlainObject');\n\nvar _isPlainObject2 = _interopRequireDefault(_isPlainObject);\n\nvar _symbolObservable = require('symbol-observable');\n\nvar _symbolObservable2 = _interopRequireDefault(_symbolObservable);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar ActionTypes = exports.ActionTypes = {\n  PERFORM_ACTION: 'PERFORM_ACTION',\n  RESET: 'RESET',\n  ROLLBACK: 'ROLLBACK',\n  COMMIT: 'COMMIT',\n  SWEEP: 'SWEEP',\n  TOGGLE_ACTION: 'TOGGLE_ACTION',\n  SET_ACTIONS_ACTIVE: 'SET_ACTIONS_ACTIVE',\n  JUMP_TO_STATE: 'JUMP_TO_STATE',\n  JUMP_TO_ACTION: 'JUMP_TO_ACTION',\n  REORDER_ACTION: 'REORDER_ACTION',\n  IMPORT_STATE: 'IMPORT_STATE',\n  LOCK_CHANGES: 'LOCK_CHANGES',\n  PAUSE_RECORDING: 'PAUSE_RECORDING'\n};\n\nvar isChrome = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && (typeof window.chrome !== 'undefined' || typeof window.process !== 'undefined' && window.process.type === 'renderer');\n\nvar isChromeOrNode = isChrome || typeof process !== 'undefined' && process.release && process.release.name === 'node';\n\n/**\n * Action creators to change the History state.\n */\nvar ActionCreators = exports.ActionCreators = {\n  performAction: function performAction(action, trace, traceLimit, toExcludeFromTrace) {\n    if (!(0, _isPlainObject2.default)(action)) {\n      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');\n    }\n\n    if (typeof action.type === 'undefined') {\n      throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n    }\n\n    var stack = void 0;\n    if (trace) {\n      var extraFrames = 0;\n      if (typeof trace === 'function') {\n        stack = trace(action);\n      } else {\n        var error = Error();\n        var prevStackTraceLimit = void 0;\n        if (Error.captureStackTrace && isChromeOrNode) {\n          // avoid error-polyfill\n          if (Error.stackTraceLimit < traceLimit) {\n            prevStackTraceLimit = Error.stackTraceLimit;\n            Error.stackTraceLimit = traceLimit;\n          }\n          Error.captureStackTrace(error, toExcludeFromTrace);\n        } else {\n          extraFrames = 3;\n        }\n        stack = error.stack;\n        if (prevStackTraceLimit) Error.stackTraceLimit = prevStackTraceLimit;\n        if (extraFrames || typeof Error.stackTraceLimit !== 'number' || Error.stackTraceLimit > traceLimit) {\n          var frames = stack.split('\\n');\n          if (frames.length > traceLimit) {\n            stack = frames.slice(0, traceLimit + extraFrames + (frames[0] === 'Error' ? 1 : 0)).join('\\n');\n          }\n        }\n      }\n    }\n\n    return { type: ActionTypes.PERFORM_ACTION, action: action, timestamp: Date.now(), stack: stack };\n  },\n  reset: function reset() {\n    return { type: ActionTypes.RESET, timestamp: Date.now() };\n  },\n  rollback: function rollback() {\n    return { type: ActionTypes.ROLLBACK, timestamp: Date.now() };\n  },\n  commit: function commit() {\n    return { type: ActionTypes.COMMIT, timestamp: Date.now() };\n  },\n  sweep: function sweep() {\n    return { type: ActionTypes.SWEEP };\n  },\n  toggleAction: function toggleAction(id) {\n    return { type: ActionTypes.TOGGLE_ACTION, id: id };\n  },\n  setActionsActive: function setActionsActive(start, end) {\n    var active = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n    return { type: ActionTypes.SET_ACTIONS_ACTIVE, start: start, end: end, active: active };\n  },\n  reorderAction: function reorderAction(actionId, beforeActionId) {\n    return { type: ActionTypes.REORDER_ACTION, actionId: actionId, beforeActionId: beforeActionId };\n  },\n  jumpToState: function jumpToState(index) {\n    return { type: ActionTypes.JUMP_TO_STATE, index: index };\n  },\n  jumpToAction: function jumpToAction(actionId) {\n    return { type: ActionTypes.JUMP_TO_ACTION, actionId: actionId };\n  },\n  importState: function importState(nextLiftedState, noRecompute) {\n    return { type: ActionTypes.IMPORT_STATE, nextLiftedState: nextLiftedState, noRecompute: noRecompute };\n  },\n  lockChanges: function lockChanges(status) {\n    return { type: ActionTypes.LOCK_CHANGES, status: status };\n  },\n  pauseRecording: function pauseRecording(status) {\n    return { type: ActionTypes.PAUSE_RECORDING, status: status };\n  }\n};\n\nvar INIT_ACTION = exports.INIT_ACTION = { type: '@@INIT' };\n\n/**\n * Computes the next entry with exceptions catching.\n */\nfunction computeWithTryCatch(reducer, action, state) {\n  var nextState = state;\n  var nextError = void 0;\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n    if (isChrome) {\n      // In Chrome, rethrowing provides better source map support\n      setTimeout(function () {\n        throw err;\n      });\n    } else {\n      console.error(err);\n    }\n  }\n\n  return {\n    state: nextState,\n    error: nextError\n  };\n}\n\n/**\n * Computes the next entry in the log by applying an action.\n */\nfunction computeNextEntry(reducer, action, state, shouldCatchErrors) {\n  if (!shouldCatchErrors) {\n    return { state: reducer(state, action) };\n  }\n  return computeWithTryCatch(reducer, action, state);\n}\n\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, shouldCatchErrors) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (!computedStates || minInvalidatedStateIndex === -1 || minInvalidatedStateIndex >= computedStates.length && computedStates.length === stagedActionIds.length) {\n    return computedStates;\n  }\n\n  var nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n  for (var i = minInvalidatedStateIndex; i < stagedActionIds.length; i++) {\n    var actionId = stagedActionIds[i];\n    var action = actionsById[actionId].action;\n\n    var previousEntry = nextComputedStates[i - 1];\n    var previousState = previousEntry ? previousEntry.state : committedState;\n\n    var shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    var entry = void 0;\n    if (shouldSkip) {\n      entry = previousEntry;\n    } else {\n      if (shouldCatchErrors && previousEntry && previousEntry.error) {\n        entry = {\n          state: previousState,\n          error: 'Interrupted by an error up the chain'\n        };\n      } else {\n        entry = computeNextEntry(reducer, action, previousState, shouldCatchErrors);\n      }\n    }\n    nextComputedStates.push(entry);\n  }\n\n  return nextComputedStates;\n}\n\n/**\n * Lifts an app's action into an action on the lifted store.\n */\nfunction liftAction(action, trace, traceLimit, toExcludeFromTrace) {\n  return ActionCreators.performAction(action, trace, traceLimit, toExcludeFromTrace);\n}\n\n/**\n * Creates a history state reducer from an app's reducer.\n */\nfunction liftReducerWith(reducer, initialCommittedState, monitorReducer, options) {\n  var initialLiftedState = {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: { 0: liftAction(INIT_ACTION) },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: options.shouldStartLocked === true,\n    isPaused: options.shouldRecordChanges === false\n  };\n\n  /**\n   * Manages how the history actions modify the history state.\n   */\n  return function (liftedState, liftedAction) {\n    var _ref = liftedState || initialLiftedState,\n        monitorState = _ref.monitorState,\n        actionsById = _ref.actionsById,\n        nextActionId = _ref.nextActionId,\n        stagedActionIds = _ref.stagedActionIds,\n        skippedActionIds = _ref.skippedActionIds,\n        committedState = _ref.committedState,\n        currentStateIndex = _ref.currentStateIndex,\n        computedStates = _ref.computedStates,\n        isLocked = _ref.isLocked,\n        isPaused = _ref.isPaused;\n\n    if (!liftedState) {\n      // Prevent mutating initialLiftedState\n      actionsById = _extends({}, actionsById);\n    }\n\n    function commitExcessActions(n) {\n      // Auto-commits n-number of excess actions.\n      var excess = n;\n      var idsToDelete = stagedActionIds.slice(1, excess + 1);\n\n      for (var i = 0; i < idsToDelete.length; i++) {\n        if (computedStates[i + 1].error) {\n          // Stop if error is found. Commit actions up to error.\n          excess = i;\n          idsToDelete = stagedActionIds.slice(1, excess + 1);\n          break;\n        } else {\n          delete actionsById[idsToDelete[i]];\n        }\n      }\n\n      skippedActionIds = skippedActionIds.filter(function (id) {\n        return idsToDelete.indexOf(id) === -1;\n      });\n      stagedActionIds = [0].concat(stagedActionIds.slice(excess + 1));\n      committedState = computedStates[excess].state;\n      computedStates = computedStates.slice(excess);\n      currentStateIndex = currentStateIndex > excess ? currentStateIndex - excess : 0;\n    }\n\n    function computePausedAction(shouldInit) {\n      var _extends2;\n\n      var computedState = void 0;\n      if (shouldInit) {\n        computedState = computedStates[currentStateIndex];\n        monitorState = monitorReducer(monitorState, liftedAction);\n      } else {\n        computedState = computeNextEntry(reducer, liftedAction.action, computedStates[currentStateIndex].state, false);\n      }\n      if (!options.pauseActionType || nextActionId === 1) {\n        return {\n          monitorState: monitorState,\n          actionsById: { 0: liftAction(INIT_ACTION) },\n          nextActionId: 1,\n          stagedActionIds: [0],\n          skippedActionIds: [],\n          committedState: computedState.state,\n          currentStateIndex: 0,\n          computedStates: [computedState],\n          isLocked: isLocked,\n          isPaused: true\n        };\n      }\n      if (shouldInit) {\n        if (currentStateIndex === stagedActionIds.length - 1) {\n          currentStateIndex++;\n        }\n        stagedActionIds = [].concat(stagedActionIds, [nextActionId]);\n        nextActionId++;\n      }\n      return {\n        monitorState: monitorState,\n        actionsById: _extends({}, actionsById, (_extends2 = {}, _extends2[nextActionId - 1] = liftAction({ type: options.pauseActionType }), _extends2)),\n        nextActionId: nextActionId,\n        stagedActionIds: stagedActionIds,\n        skippedActionIds: skippedActionIds,\n        committedState: committedState,\n        currentStateIndex: currentStateIndex,\n        computedStates: [].concat(computedStates.slice(0, stagedActionIds.length - 1), [computedState]),\n        isLocked: isLocked,\n        isPaused: true\n      };\n    }\n\n    // By default, agressively recompute every state whatever happens.\n    // This has O(n) performance, so we'll override this to a sensible\n    // value whenever we feel like we don't have to recompute the states.\n    var minInvalidatedStateIndex = 0;\n\n    // maxAge number can be changed dynamically\n    var maxAge = options.maxAge;\n    if (typeof maxAge === 'function') maxAge = maxAge(liftedAction, liftedState);\n\n    if (/^@@redux\\/(INIT|REPLACE)/.test(liftedAction.type)) {\n      if (options.shouldHotReload === false) {\n        actionsById = { 0: liftAction(INIT_ACTION) };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = computedStates.length === 0 ? initialCommittedState : computedStates[currentStateIndex].state;\n        currentStateIndex = 0;\n        computedStates = [];\n      }\n\n      // Recompute states on hot reload and init.\n      minInvalidatedStateIndex = 0;\n\n      if (maxAge && stagedActionIds.length > maxAge) {\n        // States must be recomputed before committing excess.\n        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, options.shouldCatchErrors);\n\n        commitExcessActions(stagedActionIds.length - maxAge);\n\n        // Avoid double computation.\n        minInvalidatedStateIndex = Infinity;\n      }\n    } else {\n      switch (liftedAction.type) {\n        case ActionTypes.PERFORM_ACTION:\n          {\n            if (isLocked) return liftedState || initialLiftedState;\n            if (isPaused) return computePausedAction();\n\n            // Auto-commit as new actions come in.\n            if (maxAge && stagedActionIds.length >= maxAge) {\n              commitExcessActions(stagedActionIds.length - maxAge + 1);\n            }\n\n            if (currentStateIndex === stagedActionIds.length - 1) {\n              currentStateIndex++;\n            }\n            var actionId = nextActionId++;\n            // Mutation! This is the hottest path, and we optimize on purpose.\n            // It is safe because we set a new key in a cache dictionary.\n            actionsById[actionId] = liftedAction;\n            stagedActionIds = [].concat(stagedActionIds, [actionId]);\n            // Optimization: we know that only the new action needs computing.\n            minInvalidatedStateIndex = stagedActionIds.length - 1;\n            break;\n          }\n        case ActionTypes.RESET:\n          {\n            // Get back to the state the store was created with.\n            actionsById = { 0: liftAction(INIT_ACTION) };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = initialCommittedState;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        case ActionTypes.COMMIT:\n          {\n            // Consider the last committed state the new starting point.\n            // Squash any staged actions into a single committed state.\n            actionsById = { 0: liftAction(INIT_ACTION) };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        case ActionTypes.ROLLBACK:\n          {\n            // Forget about any staged actions.\n            // Start again from the last committed state.\n            actionsById = { 0: liftAction(INIT_ACTION) };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        case ActionTypes.TOGGLE_ACTION:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            var _actionId = liftedAction.id;\n\n            var index = skippedActionIds.indexOf(_actionId);\n            if (index === -1) {\n              skippedActionIds = [_actionId].concat(skippedActionIds);\n            } else {\n              skippedActionIds = skippedActionIds.filter(function (id) {\n                return id !== _actionId;\n              });\n            }\n            // Optimization: we know history before this action hasn't changed\n            minInvalidatedStateIndex = stagedActionIds.indexOf(_actionId);\n            break;\n          }\n        case ActionTypes.SET_ACTIONS_ACTIVE:\n          {\n            // Toggle whether an action with given ID is skipped.\n            // Being skipped means it is a no-op during the computation.\n            var start = liftedAction.start,\n                end = liftedAction.end,\n                active = liftedAction.active;\n\n            var actionIds = [];\n            for (var i = start; i < end; i++) {\n              actionIds.push(i);\n            }if (active) {\n              skippedActionIds = (0, _difference2.default)(skippedActionIds, actionIds);\n            } else {\n              skippedActionIds = (0, _union2.default)(skippedActionIds, actionIds);\n            }\n\n            // Optimization: we know history before this action hasn't changed\n            minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n            break;\n          }\n        case ActionTypes.JUMP_TO_STATE:\n          {\n            // Without recomputing anything, move the pointer that tell us\n            // which state is considered the current one. Useful for sliders.\n            currentStateIndex = liftedAction.index;\n            // Optimization: we know the history has not changed.\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n        case ActionTypes.JUMP_TO_ACTION:\n          {\n            // Jumps to a corresponding state to a specific action.\n            // Useful when filtering actions.\n            var _index = stagedActionIds.indexOf(liftedAction.actionId);\n            if (_index !== -1) currentStateIndex = _index;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n        case ActionTypes.SWEEP:\n          {\n            // Forget any actions that are currently being skipped.\n            stagedActionIds = (0, _difference2.default)(stagedActionIds, skippedActionIds);\n            skippedActionIds = [];\n            currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n            break;\n          }\n        case ActionTypes.REORDER_ACTION:\n          {\n            // Recompute actions in a new order.\n            var _actionId2 = liftedAction.actionId;\n            var idx = stagedActionIds.indexOf(_actionId2);\n            // do nothing in case the action is already removed or trying to move the first action\n            if (idx < 1) break;\n            var beforeActionId = liftedAction.beforeActionId;\n            var newIdx = stagedActionIds.indexOf(beforeActionId);\n            if (newIdx < 1) {\n              // move to the beginning or to the end\n              var count = stagedActionIds.length;\n              newIdx = beforeActionId > stagedActionIds[count - 1] ? count : 1;\n            }\n            var diff = idx - newIdx;\n\n            if (diff > 0) {\n              // move left\n              stagedActionIds = [].concat(stagedActionIds.slice(0, newIdx), [_actionId2], stagedActionIds.slice(newIdx, idx), stagedActionIds.slice(idx + 1));\n              minInvalidatedStateIndex = newIdx;\n            } else if (diff < 0) {\n              // move right\n              stagedActionIds = [].concat(stagedActionIds.slice(0, idx), stagedActionIds.slice(idx + 1, newIdx), [_actionId2], stagedActionIds.slice(newIdx));\n              minInvalidatedStateIndex = idx;\n            }\n            break;\n          }\n        case ActionTypes.IMPORT_STATE:\n          {\n            if (Array.isArray(liftedAction.nextLiftedState)) {\n              // recompute array of actions\n              actionsById = { 0: liftAction(INIT_ACTION) };\n              nextActionId = 1;\n              stagedActionIds = [0];\n              skippedActionIds = [];\n              currentStateIndex = liftedAction.nextLiftedState.length;\n              computedStates = [];\n              committedState = liftedAction.preloadedState;\n              minInvalidatedStateIndex = 0;\n              // iterate through actions\n              liftedAction.nextLiftedState.forEach(function (action) {\n                actionsById[nextActionId] = liftAction(action, options.trace || options.shouldIncludeCallstack);\n                stagedActionIds.push(nextActionId);\n                nextActionId++;\n              });\n            } else {\n              var _liftedAction$nextLif = liftedAction.nextLiftedState;\n              // Completely replace everything.\n\n              monitorState = _liftedAction$nextLif.monitorState;\n              actionsById = _liftedAction$nextLif.actionsById;\n              nextActionId = _liftedAction$nextLif.nextActionId;\n              stagedActionIds = _liftedAction$nextLif.stagedActionIds;\n              skippedActionIds = _liftedAction$nextLif.skippedActionIds;\n              committedState = _liftedAction$nextLif.committedState;\n              currentStateIndex = _liftedAction$nextLif.currentStateIndex;\n              computedStates = _liftedAction$nextLif.computedStates;\n\n\n              if (liftedAction.noRecompute) {\n                minInvalidatedStateIndex = Infinity;\n              }\n            }\n\n            break;\n          }\n        case ActionTypes.LOCK_CHANGES:\n          {\n            isLocked = liftedAction.status;\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n        case ActionTypes.PAUSE_RECORDING:\n          {\n            isPaused = liftedAction.status;\n            if (isPaused) {\n              return computePausedAction(true);\n            }\n            // Commit when unpausing\n            actionsById = { 0: liftAction(INIT_ACTION) };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n            break;\n          }\n        default:\n          {\n            // If the action is not recognized, it's a monitor action.\n            // Optimization: a monitor action can't change history.\n            minInvalidatedStateIndex = Infinity;\n            break;\n          }\n      }\n    }\n\n    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, options.shouldCatchErrors);\n    monitorState = monitorReducer(monitorState, liftedAction);\n    return {\n      monitorState: monitorState,\n      actionsById: actionsById,\n      nextActionId: nextActionId,\n      stagedActionIds: stagedActionIds,\n      skippedActionIds: skippedActionIds,\n      committedState: committedState,\n      currentStateIndex: currentStateIndex,\n      computedStates: computedStates,\n      isLocked: isLocked,\n      isPaused: isPaused\n    };\n  };\n}\n\n/**\n * Provides an app's view into the state of the lifted store.\n */\nfunction unliftState(liftedState) {\n  var computedStates = liftedState.computedStates,\n      currentStateIndex = liftedState.currentStateIndex;\n  var state = computedStates[currentStateIndex].state;\n\n  return state;\n}\n\n/**\n * Provides an app's view into the lifted store.\n */\nfunction unliftStore(liftedStore, liftReducer, options) {\n  var _extends3;\n\n  var lastDefinedState = void 0;\n  var trace = options.trace || options.shouldIncludeCallstack;\n  var traceLimit = options.traceLimit || 10;\n\n  function getState() {\n    var state = unliftState(liftedStore.getState());\n    if (state !== undefined) {\n      lastDefinedState = state;\n    }\n    return lastDefinedState;\n  }\n\n  function dispatch(action) {\n    liftedStore.dispatch(liftAction(action, trace, traceLimit, dispatch));\n    return action;\n  }\n\n  return _extends({}, liftedStore, (_extends3 = {\n\n    liftedStore: liftedStore,\n\n    dispatch: dispatch,\n\n    getState: getState,\n\n    replaceReducer: function replaceReducer(nextReducer) {\n      liftedStore.replaceReducer(liftReducer(nextReducer));\n    }\n  }, _extends3[_symbolObservable2.default] = function () {\n    return _extends({}, liftedStore[_symbolObservable2.default](), {\n      subscribe: function subscribe(observer) {\n        if ((typeof observer === 'undefined' ? 'undefined' : _typeof(observer)) !== 'object') {\n          throw new TypeError('Expected the observer to be an object.');\n        }\n\n        function observeState() {\n          if (observer.next) {\n            observer.next(getState());\n          }\n        }\n\n        observeState();\n        var unsubscribe = liftedStore.subscribe(observeState);\n        return { unsubscribe: unsubscribe };\n      }\n    });\n  }, _extends3));\n}\n\n/**\n * Redux instrumentation store enhancer.\n */\nfunction instrument() {\n  var monitorReducer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n    return null;\n  };\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof options.maxAge === 'number' && options.maxAge < 2) {\n    throw new Error('DevTools.instrument({ maxAge }) option, if specified, ' + 'may not be less than 2.');\n  }\n\n  return function (createStore) {\n    return function (reducer, initialState, enhancer) {\n\n      function liftReducer(r) {\n        if (typeof r !== 'function') {\n          if (r && typeof r.default === 'function') {\n            throw new Error('Expected the reducer to be a function. ' + 'Instead got an object with a \"default\" field. ' + 'Did you pass a module instead of the default export? ' + 'Try passing require(...).default instead.');\n          }\n          throw new Error('Expected the reducer to be a function.');\n        }\n        return liftReducerWith(r, initialState, monitorReducer, options);\n      }\n\n      var liftedStore = createStore(liftReducer(reducer), enhancer);\n      if (liftedStore.liftedStore) {\n        throw new Error('DevTools instrumentation should not be applied more than once. ' + 'Check your store configuration.');\n      }\n\n      return unliftStore(liftedStore, liftReducer, options);\n    };\n  };\n}"]},"metadata":{},"sourceType":"script"}