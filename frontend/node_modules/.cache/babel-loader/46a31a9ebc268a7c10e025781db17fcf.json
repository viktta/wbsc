{"ast":null,"code":"var pathGetter = require('./path-getter');\n\nvar jsan = require('./');\n\nexports.getRegexFlags = function getRegexFlags(regex) {\n  var flags = '';\n  if (regex.ignoreCase) flags += 'i';\n  if (regex.global) flags += 'g';\n  if (regex.multiline) flags += 'm';\n  return flags;\n};\n\nexports.stringifyFunction = function stringifyFunction(fn, customToString) {\n  if (typeof customToString === 'function') {\n    return customToString(fn);\n  }\n\n  var str = fn.toString();\n  var match = str.match(/^[^{]*{|^[^=]*=>/);\n  var start = match ? match[0] : '<function> ';\n  var end = str[str.length - 1] === '}' ? '}' : '';\n  return start.replace(/\\r\\n|\\n/g, ' ').replace(/\\s+/g, ' ') + ' /* ... */ ' + end;\n};\n\nexports.restore = function restore(obj, root) {\n  var type = obj[0];\n  var rest = obj.slice(1);\n\n  switch (type) {\n    case '$':\n      return pathGetter(root, obj);\n\n    case 'r':\n      var comma = rest.indexOf(',');\n      var flags = rest.slice(0, comma);\n      var source = rest.slice(comma + 1);\n      return RegExp(source, flags);\n\n    case 'd':\n      return new Date(+rest);\n\n    case 'f':\n      var fn = function () {\n        throw new Error(\"can't run jsan parsed function\");\n      };\n\n      fn.toString = function () {\n        return rest;\n      };\n\n      return fn;\n\n    case 'u':\n      return undefined;\n\n    case 'e':\n      var error = new Error(rest);\n      error.stack = 'Stack is unavailable for jsan parsed errors';\n      return error;\n\n    case 's':\n      return Symbol(rest);\n\n    case 'g':\n      return Symbol.for(rest);\n\n    case 'm':\n      return new Map(jsan.parse(rest));\n\n    case 'l':\n      return new Set(jsan.parse(rest));\n\n    case 'n':\n      return NaN;\n\n    case 'i':\n      return Infinity;\n\n    case 'y':\n      return -Infinity;\n\n    default:\n      console.warn('unknown type', obj);\n      return obj;\n  }\n};","map":{"version":3,"sources":["C:/Users/aleor/Desktop/Code/wbsc/frontend/node_modules/jsan/lib/utils.js"],"names":["pathGetter","require","jsan","exports","getRegexFlags","regex","flags","ignoreCase","global","multiline","stringifyFunction","fn","customToString","str","toString","match","start","end","length","replace","restore","obj","root","type","rest","slice","comma","indexOf","source","RegExp","Date","Error","undefined","error","stack","Symbol","for","Map","parse","Set","NaN","Infinity","console","warn"],"mappings":"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","sourcesContent":["var pathGetter = require('./path-getter');\nvar jsan = require('./');\n\nexports.getRegexFlags = function getRegexFlags(regex) {\n  var flags = '';\n  if (regex.ignoreCase) flags += 'i';\n  if (regex.global) flags += 'g';\n  if (regex.multiline) flags += 'm';\n  return flags;\n};\n\nexports.stringifyFunction = function stringifyFunction(fn, customToString) {\n  if (typeof customToString === 'function') {\n    return customToString(fn);\n  }\n  var str = fn.toString();\n  var match = str.match(/^[^{]*{|^[^=]*=>/);\n  var start = match ? match[0] : '<function> ';\n  var end = str[str.length - 1] === '}' ? '}' : '';\n  return start.replace(/\\r\\n|\\n/g, ' ').replace(/\\s+/g, ' ') + ' /* ... */ ' + end;\n};\n\nexports.restore = function restore(obj, root) {\n  var type = obj[0];\n  var rest = obj.slice(1);\n  switch(type) {\n    case '$':\n      return pathGetter(root, obj);\n    case 'r':\n      var comma = rest.indexOf(',');\n      var flags = rest.slice(0, comma);\n      var source = rest.slice(comma + 1);\n      return RegExp(source, flags);\n    case 'd':\n      return new Date(+rest);\n    case 'f':\n      var fn = function() { throw new Error(\"can't run jsan parsed function\") };\n      fn.toString = function() { return rest; };\n      return fn;\n    case 'u':\n      return undefined;\n    case 'e':\n      var error = new Error(rest);\n      error.stack = 'Stack is unavailable for jsan parsed errors';\n      return error;\n    case 's':\n      return Symbol(rest);\n    case 'g':\n      return Symbol.for(rest);\n    case 'm':\n      return new Map(jsan.parse(rest));\n    case 'l':\n      return new Set(jsan.parse(rest));\n    case 'n':\n      return NaN;\n    case 'i':\n      return Infinity;\n    case 'y':\n      return -Infinity;\n    default:\n      console.warn('unknown type', obj);\n      return obj;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}