{"ast":null,"code":"'use strict';\n/**\n * Constants.\n */\n\nvar errorMessage;\nerrorMessage = 'An argument without append, prepend, ' + 'or detach methods was given to `List';\n/**\n * Creates a new List: A linked list is a bit like an Array, but\n * knows nothing about how many items are in it, and knows only about its\n * first (`head`) and last (`tail`) items. Each item (e.g. `head`, `tail`,\n * &c.) knows which item comes before or after it (its more like the\n * implementation of the DOM in JavaScript).\n * @global\n * @private\n * @constructor\n * @class Represents an instance of List.\n */\n\nfunction List()\n/*items...*/\n{\n  if (arguments.length) {\n    return List.from(arguments);\n  }\n}\n\nvar ListPrototype;\nListPrototype = List.prototype;\n/**\n * Creates a new list from the arguments (each a list item) passed in.\n * @name List.of\n * @param {...ListItem} [items] - Zero or more items to attach.\n * @returns {list} - A new instance of List.\n */\n\nList.of = function ()\n/*items...*/\n{\n  return List.from.call(this, arguments);\n};\n/**\n * Creates a new list from the given array-like object (each a list item)\n * passed in.\n * @name List.from\n * @param {ListItem[]} [items] - The items to append.\n * @returns {list} - A new instance of List.\n */\n\n\nList.from = function (items) {\n  var list = new this(),\n      length,\n      iterator,\n      item;\n\n  if (items && (length = items.length)) {\n    iterator = -1;\n\n    while (++iterator < length) {\n      item = items[iterator];\n\n      if (item !== null && item !== undefined) {\n        list.append(item);\n      }\n    }\n  }\n\n  return list;\n};\n/**\n * List#head\n * Default to `null`.\n */\n\n\nListPrototype.head = null;\n/**\n * List#tail\n * Default to `null`.\n */\n\nListPrototype.tail = null;\n/**\n * Returns the list's items as an array. This does *not* detach the items.\n * @name List#toArray\n * @returns {ListItem[]} - An array of (still attached) ListItems.\n */\n\nListPrototype.toArray = function () {\n  var item = this.head,\n      result = [];\n\n  while (item) {\n    result.push(item);\n    item = item.next;\n  }\n\n  return result;\n};\n/**\n * Prepends the given item to the list: Item will be the new first item\n * (`head`).\n * @name List#prepend\n * @param {ListItem} item - The item to prepend.\n * @returns {ListItem} - An instance of ListItem (the given item).\n */\n\n\nListPrototype.prepend = function (item) {\n  if (!item) {\n    return false;\n  }\n\n  if (!item.append || !item.prepend || !item.detach) {\n    throw new Error(errorMessage + '#prepend`.');\n  }\n\n  var self, head; // Cache self.\n\n  self = this; // If self has a first item, defer prepend to the first items prepend\n  // method, and return the result.\n\n  head = self.head;\n\n  if (head) {\n    return head.prepend(item);\n  } // ...otherwise, there is no `head` (or `tail`) item yet.\n  // Detach the prependee.\n\n\n  item.detach(); // Set the prependees parent list to reference self.\n\n  item.list = self; // Set self's first item to the prependee, and return the item.\n\n  self.head = item;\n  return item;\n};\n/**\n * Appends the given item to the list: Item will be the new last item (`tail`)\n * if the list had a first item, and its first item (`head`) otherwise.\n * @name List#append\n * @param {ListItem} item - The item to append.\n * @returns {ListItem} - An instance of ListItem (the given item).\n */\n\n\nListPrototype.append = function (item) {\n  if (!item) {\n    return false;\n  }\n\n  if (!item.append || !item.prepend || !item.detach) {\n    throw new Error(errorMessage + '#append`.');\n  }\n\n  var self, head, tail; // Cache self.\n\n  self = this; // If self has a last item, defer appending to the last items append\n  // method, and return the result.\n\n  tail = self.tail;\n\n  if (tail) {\n    return tail.append(item);\n  } // If self has a first item, defer appending to the first items append\n  // method, and return the result.\n\n\n  head = self.head;\n\n  if (head) {\n    return head.append(item);\n  } // ...otherwise, there is no `tail` or `head` item yet.\n  // Detach the appendee.\n\n\n  item.detach(); // Set the appendees parent list to reference self.\n\n  item.list = self; // Set self's first item to the appendee, and return the item.\n\n  self.head = item;\n  return item;\n};\n/**\n * Creates a new ListItem: A linked list item is a bit like DOM node:\n * It knows only about its \"parent\" (`list`), the item before it (`prev`),\n * and the item after it (`next`).\n * @global\n * @private\n * @constructor\n * @class Represents an instance of ListItem.\n */\n\n\nfunction ListItem() {}\n\nList.Item = ListItem;\nvar ListItemPrototype = ListItem.prototype;\nListItemPrototype.next = null;\nListItemPrototype.prev = null;\nListItemPrototype.list = null;\n/**\n * Detaches the item operated on from its parent list.\n * @name ListItem#detach\n * @returns {ListItem} - The item operated on.\n */\n\nListItemPrototype.detach = function () {\n  // Cache self, the parent list, and the previous and next items.\n  var self = this,\n      list = self.list,\n      prev = self.prev,\n      next = self.next; // If the item is already detached, return self.\n\n  if (!list) {\n    return self;\n  } // If self is the last item in the parent list, link the lists last item\n  // to the previous item.\n\n\n  if (list.tail === self) {\n    list.tail = prev;\n  } // If self is the first item in the parent list, link the lists first item\n  // to the next item.\n\n\n  if (list.head === self) {\n    list.head = next;\n  } // If both the last and first items in the parent list are the same,\n  // remove the link to the last item.\n\n\n  if (list.tail === list.head) {\n    list.tail = null;\n  } // If a previous item exists, link its next item to selfs next item.\n\n\n  if (prev) {\n    prev.next = next;\n  } // If a next item exists, link its previous item to selfs previous item.\n\n\n  if (next) {\n    next.prev = prev;\n  } // Remove links from self to both the next and previous items, and to the\n  // parent list.\n\n\n  self.prev = self.next = self.list = null; // Return self.\n\n  return self;\n};\n/**\n * Prepends the given item *before* the item operated on.\n * @name ListItem#prepend\n * @param {ListItem} item - The item to prepend.\n * @returns {ListItem} - The item operated on, or false when that item is not\n * attached.\n */\n\n\nListItemPrototype.prepend = function (item) {\n  if (!item || !item.append || !item.prepend || !item.detach) {\n    throw new Error(errorMessage + 'Item#prepend`.');\n  } // Cache self, the parent list, and the previous item.\n\n\n  var self = this,\n      list = self.list,\n      prev = self.prev; // If self is detached, return false.\n\n  if (!list) {\n    return false;\n  } // Detach the prependee.\n\n\n  item.detach(); // If self has a previous item...\n\n  if (prev) {\n    // ...link the prependees previous item, to selfs previous item.\n    item.prev = prev; // ...link the previous items next item, to self.\n\n    prev.next = item;\n  } // Set the prependees next item to self.\n\n\n  item.next = self; // Set the prependees parent list to selfs parent list.\n\n  item.list = list; // Set the previous item of self to the prependee.\n\n  self.prev = item; // If self is the first item in the parent list, link the lists first item\n  // to the prependee.\n\n  if (self === list.head) {\n    list.head = item;\n  } // If the the parent list has no last item, link the lists last item to\n  // self.\n\n\n  if (!list.tail) {\n    list.tail = self;\n  } // Return the prependee.\n\n\n  return item;\n};\n/**\n * Appends the given item *after* the item operated on.\n * @name ListItem#append\n * @param {ListItem} item - The item to append.\n * @returns {ListItem} - The item operated on, or false when that item is not\n * attached.\n */\n\n\nListItemPrototype.append = function (item) {\n  // If item is falsey, return false.\n  if (!item || !item.append || !item.prepend || !item.detach) {\n    throw new Error(errorMessage + 'Item#append`.');\n  } // Cache self, the parent list, and the next item.\n\n\n  var self = this,\n      list = self.list,\n      next = self.next; // If self is detached, return false.\n\n  if (!list) {\n    return false;\n  } // Detach the appendee.\n\n\n  item.detach(); // If self has a next item...\n\n  if (next) {\n    // ...link the appendees next item, to selfs next item.\n    item.next = next; // ...link the next items previous item, to the appendee.\n\n    next.prev = item;\n  } // Set the appendees previous item to self.\n\n\n  item.prev = self; // Set the appendees parent list to selfs parent list.\n\n  item.list = list; // Set the next item of self to the appendee.\n\n  self.next = item; // If the the parent list has no last item or if self is the parent lists\n  // last item, link the lists last item to the appendee.\n\n  if (self === list.tail || !list.tail) {\n    list.tail = item;\n  } // Return the appendee.\n\n\n  return item;\n};\n/**\n * Expose `List`.\n */\n\n\nmodule.exports = List;","map":{"version":3,"sources":["C:/Users/aleor/Desktop/Code/wbsc/frontend/node_modules/linked-list/_source/linked-list.js"],"names":["errorMessage","List","arguments","length","from","ListPrototype","prototype","of","call","items","list","iterator","item","undefined","append","head","tail","toArray","result","push","next","prepend","detach","Error","self","ListItem","Item","ListItemPrototype","prev","module","exports"],"mappings":"AAAA;AAEA;;;;AAIA,IAAIA,YAAJ;AAEAA,YAAY,GAAG,0CACX,sCADJ;AAGA;;;;;;;;;;;;AAYA,SAASC,IAAT;AAAc;AAAc;AACxB,MAAIC,SAAS,CAACC,MAAd,EAAsB;AAClB,WAAOF,IAAI,CAACG,IAAL,CAAUF,SAAV,CAAP;AACH;AACJ;;AAED,IAAIG,aAAJ;AAEAA,aAAa,GAAGJ,IAAI,CAACK,SAArB;AAEA;;;;;;;AAOAL,IAAI,CAACM,EAAL,GAAU;AAAU;AAAc;AAC9B,SAAON,IAAI,CAACG,IAAL,CAAUI,IAAV,CAAe,IAAf,EAAqBN,SAArB,CAAP;AACH,CAFD;AAIA;;;;;;;;;AAOAD,IAAI,CAACG,IAAL,GAAY,UAAUK,KAAV,EAAiB;AACzB,MAAIC,IAAI,GAAG,IAAI,IAAJ,EAAX;AAAA,MAAuBP,MAAvB;AAAA,MAA+BQ,QAA/B;AAAA,MAAyCC,IAAzC;;AAEA,MAAIH,KAAK,KAAKN,MAAM,GAAGM,KAAK,CAACN,MAApB,CAAT,EAAsC;AAClCQ,IAAAA,QAAQ,GAAG,CAAC,CAAZ;;AAEA,WAAO,EAAEA,QAAF,GAAaR,MAApB,EAA4B;AACxBS,MAAAA,IAAI,GAAGH,KAAK,CAACE,QAAD,CAAZ;;AAEA,UAAIC,IAAI,KAAK,IAAT,IAAiBA,IAAI,KAAKC,SAA9B,EAAyC;AACrCH,QAAAA,IAAI,CAACI,MAAL,CAAYF,IAAZ;AACH;AACJ;AACJ;;AAED,SAAOF,IAAP;AACH,CAhBD;AAkBA;;;;;;AAIAL,aAAa,CAACU,IAAd,GAAqB,IAArB;AAEA;;;;;AAIAV,aAAa,CAACW,IAAd,GAAqB,IAArB;AAEA;;;;;;AAKAX,aAAa,CAACY,OAAd,GAAwB,YAAY;AAChC,MAAIL,IAAI,GAAG,KAAKG,IAAhB;AAAA,MACIG,MAAM,GAAG,EADb;;AAGA,SAAON,IAAP,EAAa;AACTM,IAAAA,MAAM,CAACC,IAAP,CAAYP,IAAZ;AACAA,IAAAA,IAAI,GAAGA,IAAI,CAACQ,IAAZ;AACH;;AAED,SAAOF,MAAP;AACH,CAVD;AAYA;;;;;;;;;AAOAb,aAAa,CAACgB,OAAd,GAAwB,UAAUT,IAAV,EAAgB;AACpC,MAAI,CAACA,IAAL,EAAW;AACP,WAAO,KAAP;AACH;;AAED,MAAI,CAACA,IAAI,CAACE,MAAN,IAAgB,CAACF,IAAI,CAACS,OAAtB,IAAiC,CAACT,IAAI,CAACU,MAA3C,EAAmD;AAC/C,UAAM,IAAIC,KAAJ,CAAUvB,YAAY,GAAG,YAAzB,CAAN;AACH;;AAED,MAAIwB,IAAJ,EAAUT,IAAV,CAToC,CAWpC;;AACAS,EAAAA,IAAI,GAAG,IAAP,CAZoC,CAcpC;AACA;;AACAT,EAAAA,IAAI,GAAGS,IAAI,CAACT,IAAZ;;AAEA,MAAIA,IAAJ,EAAU;AACN,WAAOA,IAAI,CAACM,OAAL,CAAaT,IAAb,CAAP;AACH,GApBmC,CAsBpC;AAEA;;;AACAA,EAAAA,IAAI,CAACU,MAAL,GAzBoC,CA2BpC;;AACAV,EAAAA,IAAI,CAACF,IAAL,GAAYc,IAAZ,CA5BoC,CA8BpC;;AACAA,EAAAA,IAAI,CAACT,IAAL,GAAYH,IAAZ;AAEA,SAAOA,IAAP;AACH,CAlCD;AAoCA;;;;;;;;;AAQAP,aAAa,CAACS,MAAd,GAAuB,UAAUF,IAAV,EAAgB;AACnC,MAAI,CAACA,IAAL,EAAW;AACP,WAAO,KAAP;AACH;;AAED,MAAI,CAACA,IAAI,CAACE,MAAN,IAAgB,CAACF,IAAI,CAACS,OAAtB,IAAiC,CAACT,IAAI,CAACU,MAA3C,EAAmD;AAC/C,UAAM,IAAIC,KAAJ,CAAUvB,YAAY,GAAG,WAAzB,CAAN;AACH;;AAED,MAAIwB,IAAJ,EAAUT,IAAV,EAAgBC,IAAhB,CATmC,CAWnC;;AACAQ,EAAAA,IAAI,GAAG,IAAP,CAZmC,CAcnC;AACA;;AACAR,EAAAA,IAAI,GAAGQ,IAAI,CAACR,IAAZ;;AAEA,MAAIA,IAAJ,EAAU;AACN,WAAOA,IAAI,CAACF,MAAL,CAAYF,IAAZ,CAAP;AACH,GApBkC,CAsBnC;AACA;;;AACAG,EAAAA,IAAI,GAAGS,IAAI,CAACT,IAAZ;;AAEA,MAAIA,IAAJ,EAAU;AACN,WAAOA,IAAI,CAACD,MAAL,CAAYF,IAAZ,CAAP;AACH,GA5BkC,CA8BnC;AAEA;;;AACAA,EAAAA,IAAI,CAACU,MAAL,GAjCmC,CAmCnC;;AACAV,EAAAA,IAAI,CAACF,IAAL,GAAYc,IAAZ,CApCmC,CAsCnC;;AACAA,EAAAA,IAAI,CAACT,IAAL,GAAYH,IAAZ;AAEA,SAAOA,IAAP;AACH,CA1CD;AA4CA;;;;;;;;;;;AAUA,SAASa,QAAT,GAAoB,CAAE;;AAEtBxB,IAAI,CAACyB,IAAL,GAAYD,QAAZ;AAEA,IAAIE,iBAAiB,GAAGF,QAAQ,CAACnB,SAAjC;AAEAqB,iBAAiB,CAACP,IAAlB,GAAyB,IAAzB;AAEAO,iBAAiB,CAACC,IAAlB,GAAyB,IAAzB;AAEAD,iBAAiB,CAACjB,IAAlB,GAAyB,IAAzB;AAEA;;;;;;AAKAiB,iBAAiB,CAACL,MAAlB,GAA2B,YAAY;AACnC;AACA,MAAIE,IAAI,GAAG,IAAX;AAAA,MACId,IAAI,GAAGc,IAAI,CAACd,IADhB;AAAA,MAEIkB,IAAI,GAAGJ,IAAI,CAACI,IAFhB;AAAA,MAGIR,IAAI,GAAGI,IAAI,CAACJ,IAHhB,CAFmC,CAOnC;;AACA,MAAI,CAACV,IAAL,EAAW;AACP,WAAOc,IAAP;AACH,GAVkC,CAYnC;AACA;;;AACA,MAAId,IAAI,CAACM,IAAL,KAAcQ,IAAlB,EAAwB;AACpBd,IAAAA,IAAI,CAACM,IAAL,GAAYY,IAAZ;AACH,GAhBkC,CAkBnC;AACA;;;AACA,MAAIlB,IAAI,CAACK,IAAL,KAAcS,IAAlB,EAAwB;AACpBd,IAAAA,IAAI,CAACK,IAAL,GAAYK,IAAZ;AACH,GAtBkC,CAwBnC;AACA;;;AACA,MAAIV,IAAI,CAACM,IAAL,KAAcN,IAAI,CAACK,IAAvB,EAA6B;AACzBL,IAAAA,IAAI,CAACM,IAAL,GAAY,IAAZ;AACH,GA5BkC,CA8BnC;;;AACA,MAAIY,IAAJ,EAAU;AACNA,IAAAA,IAAI,CAACR,IAAL,GAAYA,IAAZ;AACH,GAjCkC,CAmCnC;;;AACA,MAAIA,IAAJ,EAAU;AACNA,IAAAA,IAAI,CAACQ,IAAL,GAAYA,IAAZ;AACH,GAtCkC,CAwCnC;AACA;;;AACAJ,EAAAA,IAAI,CAACI,IAAL,GAAYJ,IAAI,CAACJ,IAAL,GAAYI,IAAI,CAACd,IAAL,GAAY,IAApC,CA1CmC,CA4CnC;;AACA,SAAOc,IAAP;AACH,CA9CD;AAgDA;;;;;;;;;AAOAG,iBAAiB,CAACN,OAAlB,GAA4B,UAAUT,IAAV,EAAgB;AACxC,MAAI,CAACA,IAAD,IAAS,CAACA,IAAI,CAACE,MAAf,IAAyB,CAACF,IAAI,CAACS,OAA/B,IAA0C,CAACT,IAAI,CAACU,MAApD,EAA4D;AACxD,UAAM,IAAIC,KAAJ,CAAUvB,YAAY,GAAG,gBAAzB,CAAN;AACH,GAHuC,CAKxC;;;AACA,MAAIwB,IAAI,GAAG,IAAX;AAAA,MACId,IAAI,GAAGc,IAAI,CAACd,IADhB;AAAA,MAEIkB,IAAI,GAAGJ,IAAI,CAACI,IAFhB,CANwC,CAUxC;;AACA,MAAI,CAAClB,IAAL,EAAW;AACP,WAAO,KAAP;AACH,GAbuC,CAexC;;;AACAE,EAAAA,IAAI,CAACU,MAAL,GAhBwC,CAkBxC;;AACA,MAAIM,IAAJ,EAAU;AACN;AACAhB,IAAAA,IAAI,CAACgB,IAAL,GAAYA,IAAZ,CAFM,CAIN;;AACAA,IAAAA,IAAI,CAACR,IAAL,GAAYR,IAAZ;AACH,GAzBuC,CA2BxC;;;AACAA,EAAAA,IAAI,CAACQ,IAAL,GAAYI,IAAZ,CA5BwC,CA8BxC;;AACAZ,EAAAA,IAAI,CAACF,IAAL,GAAYA,IAAZ,CA/BwC,CAiCxC;;AACAc,EAAAA,IAAI,CAACI,IAAL,GAAYhB,IAAZ,CAlCwC,CAoCxC;AACA;;AACA,MAAIY,IAAI,KAAKd,IAAI,CAACK,IAAlB,EAAwB;AACpBL,IAAAA,IAAI,CAACK,IAAL,GAAYH,IAAZ;AACH,GAxCuC,CA0CxC;AACA;;;AACA,MAAI,CAACF,IAAI,CAACM,IAAV,EAAgB;AACZN,IAAAA,IAAI,CAACM,IAAL,GAAYQ,IAAZ;AACH,GA9CuC,CAgDxC;;;AACA,SAAOZ,IAAP;AACH,CAlDD;AAoDA;;;;;;;;;AAOAe,iBAAiB,CAACb,MAAlB,GAA2B,UAAUF,IAAV,EAAgB;AACvC;AACA,MAAI,CAACA,IAAD,IAAS,CAACA,IAAI,CAACE,MAAf,IAAyB,CAACF,IAAI,CAACS,OAA/B,IAA0C,CAACT,IAAI,CAACU,MAApD,EAA4D;AACxD,UAAM,IAAIC,KAAJ,CAAUvB,YAAY,GAAG,eAAzB,CAAN;AACH,GAJsC,CAMvC;;;AACA,MAAIwB,IAAI,GAAG,IAAX;AAAA,MACId,IAAI,GAAGc,IAAI,CAACd,IADhB;AAAA,MAEIU,IAAI,GAAGI,IAAI,CAACJ,IAFhB,CAPuC,CAWvC;;AACA,MAAI,CAACV,IAAL,EAAW;AACP,WAAO,KAAP;AACH,GAdsC,CAgBvC;;;AACAE,EAAAA,IAAI,CAACU,MAAL,GAjBuC,CAmBvC;;AACA,MAAIF,IAAJ,EAAU;AACN;AACAR,IAAAA,IAAI,CAACQ,IAAL,GAAYA,IAAZ,CAFM,CAIN;;AACAA,IAAAA,IAAI,CAACQ,IAAL,GAAYhB,IAAZ;AACH,GA1BsC,CA4BvC;;;AACAA,EAAAA,IAAI,CAACgB,IAAL,GAAYJ,IAAZ,CA7BuC,CA+BvC;;AACAZ,EAAAA,IAAI,CAACF,IAAL,GAAYA,IAAZ,CAhCuC,CAkCvC;;AACAc,EAAAA,IAAI,CAACJ,IAAL,GAAYR,IAAZ,CAnCuC,CAqCvC;AACA;;AACA,MAAIY,IAAI,KAAKd,IAAI,CAACM,IAAd,IAAsB,CAACN,IAAI,CAACM,IAAhC,EAAsC;AAClCN,IAAAA,IAAI,CAACM,IAAL,GAAYJ,IAAZ;AACH,GAzCsC,CA2CvC;;;AACA,SAAOA,IAAP;AACH,CA7CD;AA+CA;;;;;AAIAiB,MAAM,CAACC,OAAP,GAAiB7B,IAAjB","sourcesContent":["'use strict';\n\n/**\n * Constants.\n */\n\nvar errorMessage;\n\nerrorMessage = 'An argument without append, prepend, ' +\n    'or detach methods was given to `List';\n\n/**\n * Creates a new List: A linked list is a bit like an Array, but\n * knows nothing about how many items are in it, and knows only about its\n * first (`head`) and last (`tail`) items. Each item (e.g. `head`, `tail`,\n * &c.) knows which item comes before or after it (its more like the\n * implementation of the DOM in JavaScript).\n * @global\n * @private\n * @constructor\n * @class Represents an instance of List.\n */\n\nfunction List(/*items...*/) {\n    if (arguments.length) {\n        return List.from(arguments);\n    }\n}\n\nvar ListPrototype;\n\nListPrototype = List.prototype;\n\n/**\n * Creates a new list from the arguments (each a list item) passed in.\n * @name List.of\n * @param {...ListItem} [items] - Zero or more items to attach.\n * @returns {list} - A new instance of List.\n */\n\nList.of = function (/*items...*/) {\n    return List.from.call(this, arguments);\n};\n\n/**\n * Creates a new list from the given array-like object (each a list item)\n * passed in.\n * @name List.from\n * @param {ListItem[]} [items] - The items to append.\n * @returns {list} - A new instance of List.\n */\nList.from = function (items) {\n    var list = new this(), length, iterator, item;\n\n    if (items && (length = items.length)) {\n        iterator = -1;\n\n        while (++iterator < length) {\n            item = items[iterator];\n\n            if (item !== null && item !== undefined) {\n                list.append(item);\n            }\n        }\n    }\n\n    return list;\n};\n\n/**\n * List#head\n * Default to `null`.\n */\nListPrototype.head = null;\n\n/**\n * List#tail\n * Default to `null`.\n */\nListPrototype.tail = null;\n\n/**\n * Returns the list's items as an array. This does *not* detach the items.\n * @name List#toArray\n * @returns {ListItem[]} - An array of (still attached) ListItems.\n */\nListPrototype.toArray = function () {\n    var item = this.head,\n        result = [];\n\n    while (item) {\n        result.push(item);\n        item = item.next;\n    }\n\n    return result;\n};\n\n/**\n * Prepends the given item to the list: Item will be the new first item\n * (`head`).\n * @name List#prepend\n * @param {ListItem} item - The item to prepend.\n * @returns {ListItem} - An instance of ListItem (the given item).\n */\nListPrototype.prepend = function (item) {\n    if (!item) {\n        return false;\n    }\n\n    if (!item.append || !item.prepend || !item.detach) {\n        throw new Error(errorMessage + '#prepend`.');\n    }\n\n    var self, head;\n\n    // Cache self.\n    self = this;\n\n    // If self has a first item, defer prepend to the first items prepend\n    // method, and return the result.\n    head = self.head;\n\n    if (head) {\n        return head.prepend(item);\n    }\n\n    // ...otherwise, there is no `head` (or `tail`) item yet.\n\n    // Detach the prependee.\n    item.detach();\n\n    // Set the prependees parent list to reference self.\n    item.list = self;\n\n    // Set self's first item to the prependee, and return the item.\n    self.head = item;\n\n    return item;\n};\n\n/**\n * Appends the given item to the list: Item will be the new last item (`tail`)\n * if the list had a first item, and its first item (`head`) otherwise.\n * @name List#append\n * @param {ListItem} item - The item to append.\n * @returns {ListItem} - An instance of ListItem (the given item).\n */\n\nListPrototype.append = function (item) {\n    if (!item) {\n        return false;\n    }\n\n    if (!item.append || !item.prepend || !item.detach) {\n        throw new Error(errorMessage + '#append`.');\n    }\n\n    var self, head, tail;\n\n    // Cache self.\n    self = this;\n\n    // If self has a last item, defer appending to the last items append\n    // method, and return the result.\n    tail = self.tail;\n\n    if (tail) {\n        return tail.append(item);\n    }\n\n    // If self has a first item, defer appending to the first items append\n    // method, and return the result.\n    head = self.head;\n\n    if (head) {\n        return head.append(item);\n    }\n\n    // ...otherwise, there is no `tail` or `head` item yet.\n\n    // Detach the appendee.\n    item.detach();\n\n    // Set the appendees parent list to reference self.\n    item.list = self;\n\n    // Set self's first item to the appendee, and return the item.\n    self.head = item;\n\n    return item;\n};\n\n/**\n * Creates a new ListItem: A linked list item is a bit like DOM node:\n * It knows only about its \"parent\" (`list`), the item before it (`prev`),\n * and the item after it (`next`).\n * @global\n * @private\n * @constructor\n * @class Represents an instance of ListItem.\n */\n\nfunction ListItem() {}\n\nList.Item = ListItem;\n\nvar ListItemPrototype = ListItem.prototype;\n\nListItemPrototype.next = null;\n\nListItemPrototype.prev = null;\n\nListItemPrototype.list = null;\n\n/**\n * Detaches the item operated on from its parent list.\n * @name ListItem#detach\n * @returns {ListItem} - The item operated on.\n */\nListItemPrototype.detach = function () {\n    // Cache self, the parent list, and the previous and next items.\n    var self = this,\n        list = self.list,\n        prev = self.prev,\n        next = self.next;\n\n    // If the item is already detached, return self.\n    if (!list) {\n        return self;\n    }\n\n    // If self is the last item in the parent list, link the lists last item\n    // to the previous item.\n    if (list.tail === self) {\n        list.tail = prev;\n    }\n\n    // If self is the first item in the parent list, link the lists first item\n    // to the next item.\n    if (list.head === self) {\n        list.head = next;\n    }\n\n    // If both the last and first items in the parent list are the same,\n    // remove the link to the last item.\n    if (list.tail === list.head) {\n        list.tail = null;\n    }\n\n    // If a previous item exists, link its next item to selfs next item.\n    if (prev) {\n        prev.next = next;\n    }\n\n    // If a next item exists, link its previous item to selfs previous item.\n    if (next) {\n        next.prev = prev;\n    }\n\n    // Remove links from self to both the next and previous items, and to the\n    // parent list.\n    self.prev = self.next = self.list = null;\n\n    // Return self.\n    return self;\n};\n\n/**\n * Prepends the given item *before* the item operated on.\n * @name ListItem#prepend\n * @param {ListItem} item - The item to prepend.\n * @returns {ListItem} - The item operated on, or false when that item is not\n * attached.\n */\nListItemPrototype.prepend = function (item) {\n    if (!item || !item.append || !item.prepend || !item.detach) {\n        throw new Error(errorMessage + 'Item#prepend`.');\n    }\n\n    // Cache self, the parent list, and the previous item.\n    var self = this,\n        list = self.list,\n        prev = self.prev;\n\n    // If self is detached, return false.\n    if (!list) {\n        return false;\n    }\n\n    // Detach the prependee.\n    item.detach();\n\n    // If self has a previous item...\n    if (prev) {\n        // ...link the prependees previous item, to selfs previous item.\n        item.prev = prev;\n\n        // ...link the previous items next item, to self.\n        prev.next = item;\n    }\n\n    // Set the prependees next item to self.\n    item.next = self;\n\n    // Set the prependees parent list to selfs parent list.\n    item.list = list;\n\n    // Set the previous item of self to the prependee.\n    self.prev = item;\n\n    // If self is the first item in the parent list, link the lists first item\n    // to the prependee.\n    if (self === list.head) {\n        list.head = item;\n    }\n\n    // If the the parent list has no last item, link the lists last item to\n    // self.\n    if (!list.tail) {\n        list.tail = self;\n    }\n\n    // Return the prependee.\n    return item;\n};\n\n/**\n * Appends the given item *after* the item operated on.\n * @name ListItem#append\n * @param {ListItem} item - The item to append.\n * @returns {ListItem} - The item operated on, or false when that item is not\n * attached.\n */\nListItemPrototype.append = function (item) {\n    // If item is falsey, return false.\n    if (!item || !item.append || !item.prepend || !item.detach) {\n        throw new Error(errorMessage + 'Item#append`.');\n    }\n\n    // Cache self, the parent list, and the next item.\n    var self = this,\n        list = self.list,\n        next = self.next;\n\n    // If self is detached, return false.\n    if (!list) {\n        return false;\n    }\n\n    // Detach the appendee.\n    item.detach();\n\n    // If self has a next item...\n    if (next) {\n        // ...link the appendees next item, to selfs next item.\n        item.next = next;\n\n        // ...link the next items previous item, to the appendee.\n        next.prev = item;\n    }\n\n    // Set the appendees previous item to self.\n    item.prev = self;\n\n    // Set the appendees parent list to selfs parent list.\n    item.list = list;\n\n    // Set the next item of self to the appendee.\n    self.next = item;\n\n    // If the the parent list has no last item or if self is the parent lists\n    // last item, link the lists last item to the appendee.\n    if (self === list.tail || !list.tail) {\n        list.tail = item;\n    }\n\n    // Return the appendee.\n    return item;\n};\n\n/**\n * Expose `List`.\n */\n\nmodule.exports = List;\n"]},"metadata":{},"sourceType":"script"}