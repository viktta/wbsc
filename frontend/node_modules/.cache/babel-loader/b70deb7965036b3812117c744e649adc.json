{"ast":null,"code":"var base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar validJSONStartRegex = /^[ \\n\\r\\t]*[{\\[]/;\n\nvar arrayBufferToBase64 = function (arraybuffer) {\n  var bytes = new Uint8Array(arraybuffer);\n  var len = bytes.length;\n  var base64 = '';\n\n  for (var i = 0; i < len; i += 3) {\n    base64 += base64Chars[bytes[i] >> 2];\n    base64 += base64Chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];\n    base64 += base64Chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];\n    base64 += base64Chars[bytes[i + 2] & 63];\n  }\n\n  if (len % 3 === 2) {\n    base64 = base64.substring(0, base64.length - 1) + '=';\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + '==';\n  }\n\n  return base64;\n};\n\nvar binaryToBase64Replacer = function (key, value) {\n  if (global.ArrayBuffer && value instanceof global.ArrayBuffer) {\n    return {\n      base64: true,\n      data: arrayBufferToBase64(value)\n    };\n  } else if (global.Buffer) {\n    if (value instanceof global.Buffer) {\n      return {\n        base64: true,\n        data: value.toString('base64')\n      };\n    } // Some versions of Node.js convert Buffers to Objects before they are passed to\n    // the replacer function - Because of this, we need to rehydrate Buffers\n    // before we can convert them to base64 strings.\n\n\n    if (value && value.type === 'Buffer' && Array.isArray(value.data)) {\n      var rehydratedBuffer;\n\n      if (global.Buffer.from) {\n        rehydratedBuffer = global.Buffer.from(value.data);\n      } else {\n        rehydratedBuffer = new global.Buffer(value.data);\n      }\n\n      return {\n        base64: true,\n        data: rehydratedBuffer.toString('base64')\n      };\n    }\n  }\n\n  return value;\n}; // Decode the data which was transmitted over the wire to a JavaScript Object in a format which SC understands.\n// See encode function below for more details.\n\n\nmodule.exports.decode = function (input) {\n  if (input == null) {\n    return null;\n  } // Leave ping or pong message as is\n\n\n  if (input === '#1' || input === '#2') {\n    return input;\n  }\n\n  var message = input.toString(); // Performance optimization to detect invalid JSON packet sooner.\n\n  if (!validJSONStartRegex.test(message)) {\n    return message;\n  }\n\n  try {\n    return JSON.parse(message);\n  } catch (err) {}\n\n  return message;\n}; // Encode a raw JavaScript object (which is in the SC protocol format) into a format for\n// transfering it over the wire. In this case, we just convert it into a simple JSON string.\n// If you want to create your own custom codec, you can encode the object into any format\n// (e.g. binary ArrayBuffer or string with any kind of compression) so long as your decode\n// function is able to rehydrate that object back into its original JavaScript Object format\n// (which adheres to the SC protocol).\n// See https://github.com/SocketCluster/socketcluster/blob/master/socketcluster-protocol.md\n// for details about the SC protocol.\n\n\nmodule.exports.encode = function (object) {\n  // Leave ping or pong message as is\n  if (object === '#1' || object === '#2') {\n    return object;\n  }\n\n  return JSON.stringify(object, binaryToBase64Replacer);\n};","map":{"version":3,"sources":["C:/Users/aleor/Desktop/Code/wbsc/frontend/node_modules/sc-formatter/index.js"],"names":["base64Chars","validJSONStartRegex","arrayBufferToBase64","arraybuffer","bytes","Uint8Array","len","length","base64","i","substring","binaryToBase64Replacer","key","value","global","ArrayBuffer","data","Buffer","toString","type","Array","isArray","rehydratedBuffer","from","module","exports","decode","input","message","test","JSON","parse","err","encode","object","stringify"],"mappings":"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","sourcesContent":["var base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar validJSONStartRegex = /^[ \\n\\r\\t]*[{\\[]/;\n\nvar arrayBufferToBase64 = function (arraybuffer) {\n  var bytes = new Uint8Array(arraybuffer);\n  var len = bytes.length;\n  var base64 = '';\n\n  for (var i = 0; i < len; i += 3) {\n    base64 += base64Chars[bytes[i] >> 2];\n    base64 += base64Chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n    base64 += base64Chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n    base64 += base64Chars[bytes[i + 2] & 63];\n  }\n\n  if ((len % 3) === 2) {\n    base64 = base64.substring(0, base64.length - 1) + '=';\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + '==';\n  }\n\n  return base64;\n};\n\nvar binaryToBase64Replacer = function (key, value) {\n  if (global.ArrayBuffer && value instanceof global.ArrayBuffer) {\n    return {\n      base64: true,\n      data: arrayBufferToBase64(value)\n    };\n  } else if (global.Buffer) {\n    if (value instanceof global.Buffer){\n      return {\n        base64: true,\n        data: value.toString('base64')\n      };\n    }\n    // Some versions of Node.js convert Buffers to Objects before they are passed to\n    // the replacer function - Because of this, we need to rehydrate Buffers\n    // before we can convert them to base64 strings.\n    if (value && value.type === 'Buffer' && Array.isArray(value.data)) {\n      var rehydratedBuffer;\n      if (global.Buffer.from) {\n        rehydratedBuffer = global.Buffer.from(value.data);\n      } else {\n        rehydratedBuffer = new global.Buffer(value.data);\n      }\n      return {\n        base64: true,\n        data: rehydratedBuffer.toString('base64')\n      };\n    }\n  }\n  return value;\n};\n\n// Decode the data which was transmitted over the wire to a JavaScript Object in a format which SC understands.\n// See encode function below for more details.\nmodule.exports.decode = function (input) {\n  if (input == null) {\n   return null;\n  }\n  // Leave ping or pong message as is\n  if (input === '#1' || input === '#2') {\n    return input;\n  }\n  var message = input.toString();\n\n  // Performance optimization to detect invalid JSON packet sooner.\n  if (!validJSONStartRegex.test(message)) {\n    return message;\n  }\n\n  try {\n    return JSON.parse(message);\n  } catch (err) {}\n  return message;\n};\n\n// Encode a raw JavaScript object (which is in the SC protocol format) into a format for\n// transfering it over the wire. In this case, we just convert it into a simple JSON string.\n// If you want to create your own custom codec, you can encode the object into any format\n// (e.g. binary ArrayBuffer or string with any kind of compression) so long as your decode\n// function is able to rehydrate that object back into its original JavaScript Object format\n// (which adheres to the SC protocol).\n// See https://github.com/SocketCluster/socketcluster/blob/master/socketcluster-protocol.md\n// for details about the SC protocol.\nmodule.exports.encode = function (object) {\n  // Leave ping or pong message as is\n  if (object === '#1' || object === '#2') {\n    return object;\n  }\n  return JSON.stringify(object, binaryToBase64Replacer);\n};\n"]},"metadata":{},"sourceType":"script"}